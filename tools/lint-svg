#!/usr/bin/env node
const XMLDoc = require("xmldoc").XmlDocument;
const chalk = require("chalk");
const util = require("util");
util.inspect.styles.string = "cyan";
util.inspect.styles.regexp = "grey";
const inspect = value => util.inspect(value, {colors: true});

/**
 * All the rules we use for SVG linting
 * Are given a single argument, the parsed SVG object
 * Should throw an error if it fails
 */
const RULES = [
    function rootAttributes(svg) {
        const expected = {
            xmlns: "http://www.w3.org/2000/svg", 
            viewBox: "0 0 24 24", 
            "aria-labelledby": "title", 
            role: "img"
        };
        let msg = [];

        for (let attr in expected) {
            if (svg.attr[attr] !== expected[attr]) {
                msg.push(`Attribute ${chalk.bold(attr)} should be ${inspect(expected[attr])}, was ${inspect(svg.attr[attr])}`);
            }
        }
        Object.keys(svg.attr)
            .filter(attr => !expected.hasOwnProperty(attr))
            .forEach(attr => {
                msg.push(`Attribute ${chalk.bold(attr)} should not exist`);
            });

        if (msg.length) {
            throw new Error(msg.join("\n"));
        }
    },

    function checkTitle(svg) {
        const titles = svg.children.filter(elm => elm.name === "title");
        if (titles.length === 0) {
            throw new Error(`${chalk.bold("<title>")} must exist`);
        }
        if (titles.length > 1) {
            throw new Error(`${chalk.bold("<title>")} should exists once, found ${inspect(titles.length)}`);
        }

        const title = titles[0];
        if (!title.val || !/icon$/.test(title.val)) {
            throw new Error(`${chalk.bold("<title>")} should have format ${inspect("[name] icon")}, was ${inspect(title.val)}`);
        }
    }
];

function lintSVG(svgStr) {
    const svg = new XMLDoc(svgStr);

    const messages = [];
    for (let rule of RULES) {
        try {
            rule(svg);
        } catch (e) {
            messages.push(e.message);
        }
    }
    return messages;
}

/**
 * Gets all children of an element. The resulting array is flat
 * @param {Object} elm
 * @returns {Array<Object>}
 */
function extractChildren(elm) {
    const children = Object.keys(elm)
            .filter(tag => tag !== "$" && tag !== "_")
            .reduce((elms,tag) => elms.concat(elm[tag]), [])
            .map(child => child instanceof Array ? extractChildren(child) : child)
            .concat(elm);
    
    return children;
}

module.exports = async (name, content) => {
    const messages = await lintSVG(content);
    if (messages.length) {
        console.log(chalk.red(`✖ ${name}`));
        for (let msg of messages) {
            console.log(msg.split("\n")
                .map(msg => `    ${chalk.red(msg)}`)
                .join("\n"));
        }
    } else {
        console.log(chalk.green(`✔ ${name}`));
    }
    return !messages.length;
};
if (require.main === module) {
    // TODO: get file paths from argv and lint them
}